#include <stdio.h>
#include <pthread.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <sys/time.h>

#define INPUT_SIZE 8
#define NUM_THREADS 4
#define DEBUG

typedef struct {
	int thread_id;
	int pstart;
	int start;
	int end;
	int pend;
	int first_thread;
	int last_thread;
} prefixSumMsg;

pthread_barrier_t cbarr[NUM_THREADS], obarr[NUM_THREADS];
//int input [INPUT_SIZE];
//int check [INPUT_SIZE];
int sum1 [NUM_THREADS];
int sum2 [NUM_THREADS];
int pivots [NUM_THREADS];
int pivots_indices [NUM_THREADS];
//int input1[INPUT_SIZE]={5,6,14,13,12,11,10,9,8,7,1,2,4,3,16,15};
int input2 [INPUT_SIZE];
//int check[INPUT_SIZE]={5,6,14,13,12,11,10,9,8,7,1,2,4,3,16,15};
prefixSumMsg ps_msg[NUM_THREADS];

int input1[INPUT_SIZE]={13,12,17,15,14,11,16,18};
int check[INPUT_SIZE]={3,1,7,0,4,1,6,3};

int kth_smallest(int a[], int p, int r, int k) {
    int i,j,l = p,m = r-1 ;
    int x, t;
    while (l<m) {
        x=a[k] ;
        i=l ;
        j=m ;
        do {
            while (a[i]<x) i++ ;
            while (x<a[j]) j-- ;
            if (i<=j) {
		t = a[i];
		a[i] = a[j];
		a[j] = t;
                i++ ; j-- ;
            }
        } while (i<=j) ;
        if (j<k) l=i ;
        if (k<i) m=j ;
    }

    return k;
}

void *calcPrefixSum(void* tid) {
	int inc_1, inc, left, temp, i, j, right, depth, cnt1, cnt2;
	int  prev_lt, prev_end, pstart;
	int first, last, num_threads, group, s, e, rem, k, barr_id, t;
	int thread_id = *(int *)tid;
	int *from, *to, *tp;
	from = input1;
	to   = input2;

	while(true) {

	printf("\nThread id: %d pstart: %d pend: %d start: %d end: %d first_thread:%d last_thread: %d\n", ps_msg[thread_id].thread_id, ps_msg[thread_id].pstart, ps_msg[thread_id].pend, ps_msg[thread_id].start, ps_msg[thread_id].end, ps_msg[thread_id].first_thread, ps_msg[thread_id].last_thread);
	barr_id = ps_msg[thread_id].first_thread;
	
	if(barr_id == ps_msg[thread_id].last_thread) {
		printf("\n\nThread %d: RETURNED\n\n", thread_id);
		return NULL;
	}
	/* local rearrangement in each chunk with in the partition 
	 * Dutch National Flag - 2 partitioning */
	i = ps_msg[thread_id].start;
	printf("Start: Thread %d: barr_id: %d\n", thread_id, barr_id);
	if(thread_id == barr_id) {
		i++;
	}
	for(cnt1 = 0, j = ps_msg[thread_id].end; i <= j;) {
		if(from[i] > pivots[barr_id]) {
			temp = from[i];
			from[i] = from[j];
			from[j] = temp;
			j--;
		} else {
			i++;
			cnt1++;
		}
	}
	sum1[thread_id] = cnt1;
	cnt2 = (ps_msg[thread_id].end - ps_msg[thread_id].start + 1) - cnt1;
	if(thread_id == barr_id) {
		cnt2--;
	}
	sum2[thread_id] = cnt2;
	pthread_barrier_wait(&cbarr[barr_id]);
	
	if(thread_id == barr_id) {
		printf("\nLocal Rearragement on %d cnt1: %d cnt2: %d: \n",thread_id, cnt1, cnt2);
		for(i = 0; i < INPUT_SIZE; i++){
			printf("%d ",from[i]);
		}
		printf("\n");
		printf("Before Prefix Sum1: ");
		for(i = barr_id; i <= ps_msg[thread_id].last_thread; i++){
			printf("%d ",sum1[i]);
		}
		printf("\n");
		int psum = 0, s = 0;
		for(i = barr_id; i <= ps_msg[thread_id].last_thread; i++) {
			s += sum1[i];
			sum1[i] = psum;
			psum = s;
		}
		printf("Prefix Sum1: ");
		for(i = barr_id; i <= ps_msg[thread_id].last_thread; i++){
			printf("%d ",sum1[i]);
		}
		printf("\n");
	} else if(thread_id == ps_msg[thread_id].last_thread) {
		printf("Before Prefix Sum2: ");
		for(i = barr_id; i <= ps_msg[thread_id].last_thread; i++){
			printf("%d ",sum2[i]);
		}
		printf("\n");
		int psum = 0, s = 0;
		for(i = barr_id; i <= ps_msg[thread_id].last_thread; i++) {
			s += sum2[i];
			sum2[i] = psum;
			psum = s;
		}
		printf("Prefix Sum2: ");
		for(i = barr_id; i <= ps_msg[thread_id].last_thread; i++){
			printf("%d ",sum2[i]);
		}
		printf("\n");
		printf("Pivot index is : %d\n",pivots_indices[barr_id]);
	}
	pthread_barrier_wait(&cbarr[barr_id]);
	/* Copy elements to a new array */
	i = ps_msg[thread_id].start;
	if(thread_id == barr_id) {
		i++;
		to[pivots_indices[barr_id]] = pivots[barr_id];
	}
	pstart = ps_msg[thread_id].pstart;
	if(cnt1 != 0) { 
		memcpy((void*)(to+(sum1[thread_id])), (void*)(from+i), cnt1*sizeof(int));
	}
	if(cnt2 != 0) {
		memcpy((void*)(to+pivots_indices[barr_id]+1+sum2[thread_id]),(void*)(from+i+cnt1), cnt2*sizeof(int));
	}
	pthread_barrier_wait(&cbarr[barr_id]);

	if(thread_id == barr_id) {
		prev_end = ps_msg[thread_id].pend;
		prev_lt  = ps_msg[thread_id].last_thread;
		tp = from;
		from = to;
		to   = tp;
		printf("Final: ");
		for(i = 0; i < INPUT_SIZE; i++){
			printf("%d ",from[i]);
		}
		printf("\n");
		num_threads = ps_msg[thread_id].last_thread - barr_id + 1;
		first = num_threads/2;
		last  = num_threads - first;
		k     = pivots_indices[barr_id] - ps_msg[thread_id].start; 
		group = (first > 0)?k/first:k;
		rem   = (first > 0)?k%first:0;
		printf("\n---------First Paritioning: k:%d group:%d rem:%d first: %d last: %d------------\n", k, group, rem, first, last);
		for(i = barr_id, s = 0, e = ps_msg[thread_id].start-1; i < first; i++) {
			s = e + 1;
			e = s + group - 1;
			if(rem > 0) {
				rem--;
				e++;
			}
			ps_msg[i].pstart = ps_msg[thread_id].pstart;
			ps_msg[i].pend   = k-1;
			ps_msg[i].start = s;
			ps_msg[i].end   = e;
			ps_msg[i].first_thread = ps_msg[thread_id].first_thread;
			ps_msg[i].last_thread  = first-1;
		}
		k     = prev_end - pivots_indices[barr_id] + 1; 
		group = (last > 0)?k/last:k;
		rem   = (last > 0)?k%last:0;

		printf("\n---------Second Paritioning: k:%d group:%d rem:%d first: %d last: %d------------\n", k, group, rem, first, last);
		for(i = first; i < (first+last); i++) {
			s = e + 1;
			e = s + group - 1;
			if(rem > 0) {
				rem--;
				e++;
			}
			ps_msg[i].pstart = k;
			ps_msg[i].pend   = prev_end;
			ps_msg[i].start = s;
			ps_msg[i].end   = e;
			ps_msg[i].first_thread = first;
			ps_msg[i].last_thread  = first+last-1;
		}
		for(i = 0; i < NUM_THREADS; i++) {
			printf("Thread id: %d pstart: %d pend: %d start: %d end: %d first_thread:%d last_thread: %d\n", ps_msg[i].thread_id, ps_msg[i].pstart, ps_msg[i].pend, ps_msg[i].start, ps_msg[i].end, ps_msg[i].first_thread, ps_msg[i].last_thread);
		}
		
		printf("Finding median from %d to %d\n", ps_msg[thread_id].pstart , k-1);
		s = kth_smallest(from, ps_msg[barr_id].pstart, k-1, (k/2));
		printf("\n");
		pivots_indices[barr_id] = s;
		pivots[barr_id] = t = from[s]; 
		from[s] = from[ps_msg[thread_id].pstart];
		from[ps_msg[thread_id].pstart] = t;
		printf("First Median: %d pos: %d Index: %d\n",pivots[barr_id], s, ps_msg[thread_id].first_thread);
		/*
		pivots_indices[barr_id] = ps_msg[thread_id].pstart;
		pivots[barr_id] = from[ps_msg[thread_id].pstart];
		pivots_indices[first] = ps_msg[first].pstart;
		pivots[first] = from[ps_msg[first].pstart];
		printf("Pivot for barr_id: %d in %d, first: %d in %d\n", pivots[barr_id],
				pivots_indices[barr_id], pivots[first], pivots_indices[first]);
		*/
		printf("Finding median from %d to %d\n", k , prev_end);
		e = kth_smallest(from, k, prev_end, (prev_end-k+1)/2);
		printf("Median: %d pos: %d\n",from[e], e);
		printf("After median ");
		for(i = 0; i < INPUT_SIZE; i++){
			printf("%d ",from[i]);
		}
		printf("\n");
		e+=k;
		pivots_indices[first] = e;
		pivots[first] = t = from[e]; 
		from[e] = from[k];
		from[k] = t;
		printf("Second Median: %d pos: %d Index: %d\n",pivots[first], e, first);
		printf("Input: ");
		for(i = 0; i < INPUT_SIZE; i++){
			printf("%d ",from[i]);
		}
		
		printf("\n--------------------------------------------------------\n\n");
		//pthread_barrier_destroy(&cbarr[barr_id]);
		printf("cbarr: %d %d\n",barr_id, first);
		pthread_barrier_init(&cbarr[barr_id], NULL, first);
		//pthread_barrier_destroy(&cbarr[first]);
		printf("cbarr: %d %d\n",first, last);
		pthread_barrier_init(&cbarr[first], NULL, last);
		for(i = barr_id+1; i <= prev_lt; i++) {
			pthread_barrier_wait(&obarr[i]);
		}
		printf("Thread id: %d Master thread done !!\n", thread_id);
	} else {
		pthread_barrier_wait(&obarr[thread_id]);
	  }

	}
}



void spawn_threads(const int len, const int num_threads) {
	pthread_t threads[NUM_THREADS];
	int i, t;
	for(i = 0; i < NUM_THREADS; i++) {
		pthread_barrier_init(&cbarr[i], NULL, NUM_THREADS);
		pthread_barrier_init(&obarr[i], NULL, 2);
	}
	int group = len / num_threads;
	int rem   = len % num_threads;
	int s = 0, e = -1;
	printf("Input: ");
	for(int i = 0; i < INPUT_SIZE; i++){
			printf("%d ",input1[i]);
	}
	printf("\n");
	
	i = kth_smallest(input1, 0, INPUT_SIZE-1, INPUT_SIZE/2);
	pivots[0] = input1[i];	
	pivots_indices[0] = i;
	printf("Median: %d pos: %d\n",input1[i], i);
	printf("After median ");
	for(int i = 0; i < INPUT_SIZE; i++){
			printf("%d ",input1[i]);
	}
	printf("\n");
	t = input1[0];
	input1[0] = input1[i];
	input1[i] = t;
	for(int i = 0; i < INPUT_SIZE; i++){
			printf("%d ",input1[i]);
	}
	printf("\n");

	for(i = 0; i < num_threads; i++) {
		s = e + 1;
		e = s + group - 1;
		if(rem > 0) {
			rem--;
			e++;
		}
		ps_msg[i].thread_id  = i;
		ps_msg[i].start = s;
		ps_msg[i].end   = e;
		ps_msg[i].pstart = 0;
		ps_msg[i].pend   = len-1;
		ps_msg[i].last_thread = NUM_THREADS-1;
		ps_msg[i].first_thread = 0;
		int rc = pthread_create(&threads[i], NULL, calcPrefixSum, 
				        (void *)& ps_msg[i].thread_id);
		if(rc == -1) {
			printf("prefixSum: pthread_create\n",__func__);
			exit(EXIT_FAILURE);
		}
	}
	for(i = 0; i < NUM_THREADS; i++) {
		pthread_join(threads[i], NULL);
	}
}


int main() {
    srand(time(NULL));
    for(int i = 0; i < INPUT_SIZE; i++) {
//	 check[i] = input[i] = rand()%2;
    }
    double sTime, pTime;
    struct timeval tz;
    struct timezone tx;
    double start_time, end_time;
    gettimeofday(&tz, &tx);
    start_time = (double)tz.tv_sec + (double) tz.tv_usec / 1000000.0;

    spawn_threads(INPUT_SIZE, NUM_THREADS);

    gettimeofday(&tz, &tx);
    end_time = (double)tz.tv_sec + (double) tz.tv_usec / 1000000.0;
    pTime = end_time-start_time;
    printf("Parallel Time: time_p - %lf\n", pTime);
/*
	for(int i = 0; i < sumLimit; i++){
		printf("%d ",sum[i]);
	}
	printf("\n");
*/
    gettimeofday(&tz, &tx);
    start_time = (double)tz.tv_sec + (double) tz.tv_usec / 1000000.0;

    for(int i = 1; i < INPUT_SIZE; i++) {
	    check[i] += check[i-1];
    }

    gettimeofday(&tz, &tx);
    end_time = (double)tz.tv_sec + (double) tz.tv_usec / 1000000.0;
    sTime = end_time-start_time;
    printf("Serial Time: time_s - %lf\n", sTime);

    /*
    for(int i=0;i<INPUT_SIZE;i++){
	 if(input[i] != check[i]){
		printf("------FAIL:%d %d-------\n",input[i], check[i]);
	}
		printf("%d %d\n",input[i], check[i]);
    }
    */
    printf("Speedup: %lf\n",(double)sTime/pTime);
	
    return EXIT_SUCCESS;
}
